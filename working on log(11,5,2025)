setenv('key', 'sk-b5477d92aaec47649c442c44d0157b9b'); 

% Files:  
pulse = 'request_pulse.json';
linear = 'request_chirp_linear.json';
log = 'request_chirp_log.json';
step = 'request_step_frequency.json';
phase = 'request_phase_coded.json';

spec = log;

% making sure file passed is json file
if ischar(spec) || isstring(spec)
    raw = jsondecode(fileread(spec));
else
    raw = spec;
end


p = normalize_parameters(raw);

dt = 1/p.fs;                            % time between point
N = round(p.duration* p.fs);               % number of points
t = single((0:N-1).' * dt);             % creates time vector 


switch lower(p.type)
    case 'continuous_pulse'
        A = single(p.A);
        w = 2*pi*single(p.pulse.freqHz);
        ph = single(p.pulse.ph0);
        PRI = p.pulse.PRI;
        tau = p.pulse.tau;
        msg = sprintf( ...
            "Return only runnable MATLAB code.\n" + ...
            "Define EXACTLY this function:\n" + ...
            "function iq = continuous_pulse(t, A, w, ph, PRI, tau)\n" + ...
            "%% t is seconds (column vector). Return complex single column vector iq.\n" + ...
            "%% iq = A*exp(1j*(w*t + ph)) gated by (mod(t,PRI) < tau)." ...
        );

        [fn,code] = project_403_api_call(msg,"generated/continuous_pulse.m",'LanguageHint',"MATLAB");
        addpath("generated");
        if ~exist("generated/continuous_pulse.m","file")
            error("Continuous_pulse.m not created.");
        end

        % use generated code for Iq
        iq = continuous_pulse(t, A, w, ph, PRI, tau);

        % test iq
        rehash;        
        % ---- Build a reference IQ to validate the generated code
        gate    = single(mod(t, PRI) < tau);
        iq_ref  = single(A) .* gate .* exp(1j*(w.*t + ph));
        
        % Max error check
        maxerr = max(abs(iq - iq_ref));
        fprintf("Max |error| vs reference = %.3g\n", maxerr);

        % ---- Plot
        tp    = t * 1e3;        
        
        figure('Name','IQ Check'); 
        
        subplot(2,2,1);
        plot(tp, real(iq)); grid on;
        xlabel('Time (ms)'); ylabel('I'); title('In-phase');
        
        subplot(2,2,2);
        plot(tp, imag(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Q'); title('Quadrature');
        
        subplot(2,2,3);
        plot(tp, abs(iq)); grid on; hold on;
        plot(tp, single(A)*gate, '--');  % shows the gating envelope
        xlabel('Time (ms)'); ylabel('|IQ|'); title('Magnitude (with gate overlay)');
        legend('|IQ|','gate·A','Location','best'); legend boxoff;
        
        subplot(2,2,4);
        plot(tp, angle(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Phase (rad)'); title('Phase');



    case 'fm_linear'
        A = single(p.A);
        bw = p.linear.bw;
        center_freq = p.linear.center_freq;
        T = p.linear.chirpDur;
        f0 = center_freq - bw/2;
        W = bw / T;    % chirp rate
        tt = double(t);

        msg = sprintf( ...
            "Return only runnable MATLAB code.\n" + ...
            "Define EXACTLY this function:\n" + ...
            "function iq = fm_linear(tt,A,W,f0,T)\n" + ...
            "%% tt: seconds (column). A: amplitude. W: chirp rate (Hz/s). f0: start Hz. T: chirp duration (s).\n" + ...
            "%% Phase-continuous: chirp from f0 to f1=f0+W*T over [0,T], then hold f1 after T.\n" + ...
            "tt = double(tt); A = single(A); W = double(W); f0 = double(f0); T = double(T);\n" + ...
            "f1 = f0 + W*T;\n" + ...
            "phi_T = 2*pi*(f0*T + 0.5*W*T.^2);\n" + ...
            "phi = zeros(size(tt));\n" + ...
            "m = tt < T;\n" + ...
            "phi(m)  = 2*pi*(f0*tt(m) + 0.5*W*tt(m).^2);\n" + ...
            "phi(~m) = phi_T + 2*pi*f1*(tt(~m) - T);\n" + ...
            "y  = exp(1j*phi);\n" + ...
            "iq = A .* complex(single(real(y)), single(imag(y)));\n" + ...
            "end\n");

        [fn,code] = project_403_api_call(msg,"generated/fm_linear.m",'LanguageHint',"MATLAB");
        addpath("generated"); rehash;
        if ~exist("generated/fm_linear.m","file")
            error("fm_linear.m not created");
        end

        % generated iq
        iq = fm_linear(tt,A,W,f0,T);

        % iq test
        rehash;
        % rebuild reference
        A = single(p.A);
        T = p.linear.chirpDur;
        f0_ref = p.linear.center_freq - p.linear.bw/2;
        W_ref = p.linear.bw / T;
        f1_ref = f0_ref + W_ref*T;
        tt = double(t);

        phi_ref = zeros(size(tt));
        m       = tt < T;
        phi_ref(m)  = 2*pi*(f0_ref*tt(m) + 0.5*W_ref*tt(m).^2);
        phi_T       = 2*pi*(f0_ref*T   + 0.5*W_ref*T.^2);
        phi_ref(~m) = phi_T + 2*pi*f1_ref*(tt(~m)-T);
        
        yref        = exp(1j*phi_ref);
        iq_ref_pw   = A .* complex(single(real(yref)), single(imag(yref)));
        
        % Error vs. correct piecewise reference
        err = max(abs(iq - iq_ref_pw));
        fprintf("Max |error| vs piecewise ref = %.3g\n", err);
        
        % Plots 
        tp = t * 1e3;   % ms
        figure('Name','FM Linear IQ Check (Full Duration)');
        
        subplot(2,2,1);
        plot(tp, real(iq)); grid on;
        xlabel('Time (ms)'); ylabel('I');
        title('In-phase (full duration)'); xlim([tp(1) tp(end)]);
        
        subplot(2,2,2);
        plot(tp, imag(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Q');
        title('Quadrature (full duration)'); xlim([tp(1) tp(end)]);
        
        subplot(2,2,3);
        plot(tp, abs(iq)); grid on; hold on;
        plot(tp, A*ones(size(tp)), '--');           % constant envelope expected
        xlabel('Time (ms)'); ylabel('|IQ|');
        title('Magnitude with expected envelope');
        legend('|IQ|','A (expected)', 'Location','best'); legend boxoff;
        xlim([tp(1) tp(end)]);
        
        subplot(2,2,4);
        plot(tp, angle(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Phase (rad)');
        title('Phase (full duration)'); xlim([tp(1) tp(end)]);
        
        % frequency vs time plot
        dt      = 1/p.fs;
        phi     = unwrap(angle(iq));
        f_inst  = (1/(2*pi)) * gradient(phi) / dt;   % Hz
        
        figure('Name','Instantaneous Frequency');
        plot(tp, f_inst, 'LineWidth', 1); grid on;
        xlabel('Time (ms)'); ylabel('Frequency (Hz)');
        title('Frequency');



    case 'fm_log'
        A = single(p.A);
        bw = p.log.bw;
        center_freq = p.log.center_freq;
        T = p.log.chirpDur;
        f0 = center_freq - bw/2;
        f1 = center_freq + bw/2;

        tt = double(t);

        k = log10(f1/f0);
        msg = sprintf( ...
            "Return only runnable MATLAB code.\n" + ...
            "Define EXACTLY this function:\n" + ...
            "function iq = fm_log(tt,A,k,f0,f1,T)\n" + ...
            "%% tt: seconds (column). A: amplitude. k=log(f1/f0). f0: start Hz. f1: end Hz. T: sweep duration (s).\n" + ...
            "%% Log-FM: f(t)=f0*exp(k*t/T) for 0<=t<T; phase-continuous; hold f1 after T.\n   " + ...
            "tt = double(tt); A = single(A); k = double(k); f0 = double(f0); f1 = double(f1); T = double(T);\n" + ...
            "phi = zeros(size(tt));\n" + ...
            "idx = (tt < T);\n" + ...
            "if abs(k) < 1e-12\n" + ...
            "    phi(idx) = 2*pi * f0 .* tt(idx);\n" + ...
            "    phi_T = 2*pi * f0 * T;\n" + ...
            "else\n" + ...
            "    phi(idx) = 2*pi * f0 * T / k .* (exp(k * tt(idx) / T) - 1);\n" + ...
            "    phi_T    = 2*pi * f0 * T / k * (r - 1);\n" + ...
            "end\n" + ...
            "idx_after = (tt>=T);\n" + ...
            "phi(idx_after) = phi_T + 2*pi * f1 .* (tt(idx_after) - T);\n" + ...
            "y = exp(1j*phi);\n" + ...
            "iq = A * complex(single(real(y)), single(imag(y)));\n" + ...
            "end\n");


        [fn,code] = project_403_api_call(msg,"generated/fm_log.m",'LanguageHint',"MATLAB");
        addpath("generated"); rehash;
        if ~exist("generated/fm_log.m","file")
            error("fm_log.m not created");
        end

        % generated iq
        iq = fm_log(tt,A,k,f0,f1,T);

        % test iq
        rehash;
        % rebuild reference
        A_ref  = single(p.A);
        T_ref  = p.log.chirpDur;
        f0_ref = p.log.center_freq - p.log.bw/2;
        f1_ref = p.log.center_freq + p.log.bw/2;
        k_ref  = log10(f1_ref/f0_ref);      % natural log
        tt     = double(t);
        
        phi_ref = zeros(size(tt));
        m = tt < T_ref;
        
        if abs(k_ref) < 1e-12
            % Degenerate ~ no sweep
            phi_ref(m)  = 2*pi*f0_ref*tt(m);
            phi_T       = 2*pi*f0_ref*T_ref;
        else
            phi_ref(m)  = 2*pi*(f0_ref*T_ref/k_ref).*(exp(k_ref*tt(m)/T_ref) - 1);
            phi_T       = 2*pi*(f0_ref*T_ref/k_ref)*(exp(k_ref) - 1);  % = 2π * (f0*T/k) * (f1/f0 - 1)
        end
        phi_ref(~m) = phi_T + 2*pi*f1_ref*(tt(~m) - T_ref);
        
        yref   = exp(1j*phi_ref);
        iq_ref = A_ref .* complex(single(real(yref)), single(imag(yref)));
        
        % --- Error vs reference
        maxerr = max(abs(iq - iq_ref));
        fprintf("fm\\_log max |error| vs piecewise ref: %.3g\n", maxerr);
        
        % --- Plots (full duration)
        tp = t * 1e3;   % ms
        
        figure('Name','FM Log IQ Check (Full Duration)');
        
        subplot(2,2,1);
        plot(tp, real(iq)); grid on;
        xlabel('Time (ms)'); ylabel('I');
        title('In-phase (full duration)'); xlim([tp(1) tp(end)]);
        
        subplot(2,2,2);
        plot(tp, imag(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Q');
        title('Quadrature (full duration)'); xlim([tp(1) tp(end)]);
        
        subplot(2,2,3);
        plot(tp, abs(iq)); grid on; hold on;
        plot(tp, A_ref*ones(size(tp)), '--');           % constant envelope expected
        xlabel('Time (ms)'); ylabel('|IQ|');
        title('Magnitude with expected envelope');
        legend('|IQ|','A (expected)','Location','best'); legend boxoff;
        xlim([tp(1) tp(end)]);
        
        subplot(2,2,4);
        plot(tp, angle(iq)); grid on;
        xlabel('Time (ms)'); ylabel('Phase (rad)');
        title('Phase (full duration)'); xlim([tp(1) tp(end)]);
        
        % --- Instantaneous frequency vs theory (log ramp then flat at f1)
        dt      = 1/p.fs;
        phi     = unwrap(angle(iq));
        f_inst  = (1/(2*pi)) * gradient(phi) / dt;      % Hz
        
        figure('Name','FM Log: Instantaneous Frequency');
        plot(tp, f_inst, 'LineWidth', 1); grid on;
        xlabel('Time (ms)'); ylabel('Frequency (Hz)');
        title('Frequency vs time');






    case 'step_frequency'
        disp("work in progess");

    case 'phase_coded'
        disp("work in progess");

    otherwise
        error('Unsupported type: %s', p.type);
end





% helpers
function v = getf(s,f,d)
% s is the struct
% f is the field
% d is the default
if nargin < 3
    d = [];   % if no default is provided, its empty
end
if isstruct(s) && isfield(s,f) && ~isempty(s.(f))
    v = s.(f);
else
    v = d;    % if  something is missing, use default
end

end


function p = normalize_parameters(r)
p.type = getf(r,'type');
p.type = strrep(p.type,'-','_');
p.fs = getf(r,'sampleRateHz',2e6);
p.duration = getf(r,'durationSec',0.01);
p.A = getf(r,'amplitude',0.8);

switch lower(p.type)
    case 'continuous_pulse'
        if isfield(r,'pulse') && ~isempty(r.pulse)
            c = r.pulse;
            p.pulse.freqHz = getf(c,'frequencyHz',100e3);
            p.pulse.PRI = getf(c,'repSec',p.duration);
            p.pulse.tau = getf(c,'pulseWidthSec',5e-4);
            p.pulse.ph0 = deg2rad(getf(c,'phaseDeg',0));
        else
            error('For type "continuous_pulse", the "pulse" block is required.');
        end
        % Quick checks for continuous pulse
        if p.pulse.tau > p.pulse.PRI
            warning('pulseWidthSec (%.3g) > repSec (%.3g); clamping to PRI.',p.pulse.tau,p.pulse.PRI);
            p.pulse.tau = p.pulse.PRI;
        end
        if p.pulse.freqHz >= p.fs/2
            warning('pulse.frequencyHz >= fs/2 (Nyquist). You may get aliasing.');
        end

    case 'fm_linear'
        if isfield(r,'linear') && ~isempty(r.linear)
            c = r.linear;
            p.linear.center_freq = getf(c,'center');
            p.linear.bw = getf(c,'bandwidth');
            p.linear.chirpDur = getf(c,'chirp_durSec');
        else
            error('For type "fm_linear" the "linear" block is required.');
        end
        %quick checks for fm linear
        if p.linear.bw/2 >= p.linear.center_freq
            warning('p.linear.bw is greater than center frequency');
        end
        if p.linear.center_freq + (p.linear.bw)/2 >= p.fs/2
            warning('Chirp edge frequency >= fs/2. you may get aliasing.');
        end

    case 'fm_log'
        if isfield(r,'log') && ~isempty(r.log)
            c = r.log;
            p.log.center_freq = getf(c,'center');
            p.log.bw = getf(c,'bandwidth');
            p.log.chirpDur = getf(c,'chirp_durSec');
        else
            error('For type "fm.log" the "log" block is required.');
        end
        if p.log.bw/2 >= p.log.center_freq
            warning('p.log.bw is greater than center frequency');
        end
        if p.log.center_freq + (p.log.bw)/2 >= p.fs/2
            warning("aliasing will occur");
        end

    case 'step_frequency'
        if isfield(r,'step') && ~isempty(r.step)
            c = r.step;
            p.step.f0 = getf(c,'f0');
            p.step.StepSize = getf(c,'step_size'); % in Hz
            p.step.Nsteps = getf(c,'Nsteps');
            p.step.ph0 = deg2rad(getf(c,'phaseDeg',0));
            p.step.stepDur = getf(c,'step_duration');
        else
            error('For type "step_frequency" the "step" block is required.');
        end
        if p.step.f0 >= p.fs/2
            warning("aliasing will occur");
        end

    case 'phase_coded'
        if isfield(r,'phase') && ~isempty(r.phase)
            c = r.phase;
            p.phase.chipRate = getf(c,'chipRate');
            p.phase.sequence = getf(c,'sequence');
        else
            error('For type "phase-coded", the "phase" block is required.');
        end
        % checks
        if isempty(p.phase.chipRate) ||  p.phase.chipRate <= 0
            error('phase.chipRate must be a positive scalar.');
        end
        if isempty(p.phase.sequence)
            error('phase.sequence must be a non-empty vector of +/-1 values.');
        end
        seq = p.phase.sequence(:);
        if any(~ismember(seq,[-1,1]))
            warning('phase.sequence contains values other than +/-1; applying sign().');
            p.phase.sequence = sign(seq);
            p.phase.sequence(p.phase.sequence == 0) = 1; % maps any 0 to +1
        end

    otherwise
        error('Unsupported type: %s',p.type);
end  % for switch case

end



% [fn, code] = project_403_api_call( ...
%     "Write MATLAB code that defines a function plus_five which returns the input number + 5.", ...
%     "generated/plus_five.m", ...
%     'LanguageHint',"MATLAB");
% 
% 
% exist("generated/plus_five.m","file");
% type generated/plus_five.m
% movefile("generated/plus_five.m","generated/plusfive.m");
% 
% addpath("generated");
% y = plusfive(25)
